import { Assumption } from "./agent.js";

/**
 * Do the Update Method and Eval Method
 */

class LogicWorker {
  constructor(rDatabase, threshold, ast) {
    //this.rDatabase = rDatabase;
    this.threshold = threshold;
    //databases generated by update's method
    //this.generatedDatabases = [];

    console.log("bla");
    //var cur = ast.first;
    //var return = eval(cur, rDatabase);
  }

  /**
   * var logicAST; //AST three of logical command
//"cur" for current
var cur = logicAST.first; //define o topo da tree em cur
var retorno = eval(cur); // chama a function mandando cur
eval(cur){
	if(cur.type=="AND")
		var firstRetorno = eval(cur.firstChild);
		var secondRetorno = eval(cur.secondChild);
		if(firstRetorno && secondRetorno)
			return true;
	else if(cur.type=="NOT")
		return !eval(cur.child);
	else if(cur.type=="ADOPT")
		updateFunction();
		return eval(cur.child);
	else if(cur.type=="NbStm")
		return checkNeighbor(cur.agent1, cur.agent2);	//check inside list of Links
	else if(cur.type=="AsStm")
		return checkAssumption(cur.agent, cur.assumption);	//check inside list of assumptions
}
functionShowResult(retorno);
   */

  /**
   * EVAL Method
   * Commands:
   * B(#agent#,#behavior#)  ---> for to check inside list of assumptions
   * N(#agent#,#behavior#)  ---> for to check inside list of links
   * !Phi and Phi&&Phi      ---> need to consider AST
   * [adopt] Phi            ---> update one time all behaviors
   * [adopt,#behavior#] Phi ---> update one time based on received behavior
   *
   * Input: M=(A,N,β,θ) & Phi & current AST command
   * Output: #true#/#false#
   *
   */
  eval(cur, curDatabase) {
    switch (cur.type) {
      case "AND":
        let firstReturn = eval(cur.firstChild, curDatabase);
        let secondReturn = eval(cur.secondChild, curDatabase);
        if (firstReturn && secondReturn) return true;
        return false;
      case "NOT":
        return !this.eval(cur.child, curDatabase);
      case "ADOPT":
        //check if behavior received ********
        let newDatabase = this.update(...curDatabase, this.threshold, null);
        return this.eval(cur.child, newDatabase);
      case "NbStm":
        return checkIfNeighbor(curDatabase.links, cur.agent1, cur.agent2);
      case "AsStm":
        return checkAgentBiPair(
          curDatabase.assumptions,
          cur.agent,
          cur.behavior
        );
    }
    //shouldn't go here
    return false;
  }

  /**
   * UPDATE Method
   * Input: M=(A,N ,β,θ) & Bi
   * Output: M′=(A,N ,β′,θ)
   * database contains (mapping: logic -> dataArray):
   *    Agents -> nodes
   *    Network -> links
   *    List of B -> behaviors
   *    β -> assumptions
   * θ -> threshold
   * Bi -> current behavior being treated
   * I made a reducedDatabase without plotting informations
   * that's the one planed to be used
   *
   * agents assume the received behavior when the result of:
   *    "conections" divided by "holders" is greater than "threshold"
   * "conections" being the number of neighbors
   * "holders" being the number of neighbors that have the assumption Bi
   */
  update(rDatabase, thresold, behaviorID) {
    //check all agents
    for (let agent in rDatabase.nodes) {
      //if the agent already assume Bi the test isn't needed
      if (this.checkAgentBiPair(rDatabase.assumptions, agent.id, behaviorID))
        continue;
      else {
        let conections = 0;
        let holders = 0;
        for (let link in rDatabase.links) {
          linkedTo = this.agentLinkedTo(agent.id, link);
          //if found conections
          if (linkedTo != null) {
            conections++;
            //if linkedTo already assumes Bi
            if (
              this.checkAgentBiPair(rDatabase.assumptions, linkedTo, behaviorID)
            )
              holders++;
          }
        }
        if (holders / conections >= thresold)
          rDatabase = insertAssumptionForAgent(agent.id, behaviorID, rDatabase);
      }
    }
    return rDatabase;
  }

  //check pair agent and Bi behavior
  checkAgentBiPair(assumptions, agent, Bi) {
    for (let assumption in assumptions)
      if (assumption.behavior == Bi && assumption.agent == agent) return true;
    return false;
  }

  //return false when agentId not found in this link
  //otherwise return id of the linked element
  agentLinkedTo(agentID, link) {
    if (link.source === agentID) return link.target;
    else if (link.target === agentID) return link.source;
    return false;
  }

  //create and insert new assumption
  insertAssumptionForAgent(agentID, behaviorID, rDatabase) {
    rDatabase.assumption.push(new Assumption(agentID, behaviorID));
  }

  //check if conection of both agents exists
  checkIfNeighbor(links, agent1, agent2) {
    for (let conection in links)
      if (
        (conection.agent1 === agent1 && conection.agent2 === agent2) ||
        (conection.agent1 === agent2 && conection.agent2 === agent1)
      )
        return true;
    return false;
  }
}

module.exports = { LogicWorker };
